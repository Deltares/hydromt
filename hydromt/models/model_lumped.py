from multiprocessing.sharedctypes import Value
import pytest
import sys, os

from pytz import NonExistentTimeError
from .model_api import Model
import xarray as xr
import numpy as np
import geopandas as gpd
from shapely.geometry import box

from typing import Tuple, Union, Optional, List

import logging
from os.path import join, isfile
from ..data_adapter import DataAdapter
from .. import config, log, workflows, flw

__all__ = ["LumpedModel"]
logger = logging.getLogger(__name__)

def _set_value_to_index(response_unit_geom):
    """Set values under column header 'values' as index and
    rename to index.

    Parameters
    ----------
    response_unit_geom : gpd.GeoDataFrame
        Geodataframe generated by region of basin split methods

    Returns
    -------
    gpd.GeoDataFrame
        Response unit with indexes matching the basin indexes stored in 'values'
    """    
    #response_unit_geom.rename(columns={"value": "index"},inplace=True)
    response_unit_geom['value'] = response_unit_geom['value'].astype(int)
    response_unit_geom.set_index(response_unit_geom['value'].values,inplace=True)
    return response_unit_geom
    

class LumpedModel(Model):
    def __init__(
        self,
        root: str = None,
        mode: str = "w",
        config_fn: str = None,
        data_libs: List[str] = None,
        logger=logger,
    ):
        # Initialize with the Model class
        super().__init__(
            root=root,
            mode=mode,
            config_fn=config_fn,
            data_libs=data_libs,
            logger=logger,
        )

        # placeholders
        self._response_units = (
            xr.Dataset()
        )  # representation of all response units. Geometry defined as coordinate "geometry"
    
    def setup_response_unit(
        self,
        split_regions = False,
        split_method = "us_area",
        hydrography_fn = "merit_hydro",
        **kwargs
        ):
        """
        This component sets up the region and response units.
        
        """

        if len(self.region) == 0:
            raise ValueError("No region defined. Define :py:meth:`~hydromt.models.model_api.setup_region`")
        
        if not split_regions:
            self.set_response_units(self._geoms['region'])
            self.logger.info(f"setup_response_unit.split_regions set to False. response_units set up")
        
        if split_regions:
            self.logger.info(f"setup_response_unit.split_regions set to True. Deriving response_units based on hydrography")
            
            ds = self.data_catalog.get_rasterdataset(hydrography_fn, geom = self.region)
            ds_response_units = workflows.hydrography_to_basins(
                ds,
                self.region,
                split_method,
                **kwargs
            )
            self.set_response_units(ds_response_units)
    
    def setup_downstream_links(
        self,
        hydrography_fn="merit_hydro",
        ):
        """Link basins from upstream to downstream based on flow direction map

        Args:
            outflow_gpd (gpd.GeoDataFrame): point geometries of the subbasin outlets
            hydrography_fn (str, optional): Hydrography dataset, must include flwdir variable.
            Defaults to "merit_hydro".

        Returns:
            np.array: array of downstream link ids
        """
        outflow_gpd = workflows.ru_geometry_to_gpd(self.response_units,geometry_name='outlet_geometry')
        basins_gpd =  workflows.ru_geometry_to_gpd(self.response_units)       
        ds = self.data_catalog.get_rasterdataset(hydrography_fn, geom=self.region)
        flwdir = flw.flwdir_from_da(ds["flwdir"], ftype="d8")#, mask= workflows.make_ds_mask(ds, basins_gpd, col_name='value'))
        rasterized_map = ds.raster.rasterize(basins_gpd, col_name='value')

        # TODO: make one function in flw.py
        dwn_basin = flwdir.downstream(rasterized_map.values.flatten()).reshape(ds.raster.shape)
        da_out = xr.DataArray(
                data=dwn_basin,
                coords=ds.raster.coords,
                dims=ds.raster.dims,
            )
        da_out.raster.set_nodata(0)
        da_out.raster.set_crs(ds.raster.crs)
        basins_downstream = da_out.raster.sample(outflow_gpd)
        basins_downstream = basins_downstream.drop(['x','y','spatial_ref'])
        self.set_response_units(basins_downstream, name='down_id')
    
    def read(self):
        """Method to read the complete model schematization and configuration from file."""
        super().read()
        self.read_response_units()
        # Other specifics to LumpedModel...

    def write(self):
        """Method to write the complete model schematization and configuration to file."""
        super().write()
        self.write_response_units()
        # Other specifics to LumpedModel...

    def read_response_units(self):
        if not self._write:
            # start fresh in read-only mode
            self._response_units = xr.Dataset()
        if isfile(
            join(self.root, "response_units", "response_units.nc")
        ):  # Change of file not implemented yet
            ds = xr.open_dataset(join(self.root, "response_units", "response_units.nc"))
        if isfile(join(self.root, "response_units", "response_units.geoJSON")):
            gdf = gpd.GeoDataFrame(
                join(self.root, "response_units", "response_units.geoJSON")
            )
            self._response_units = ds.assign_coords(
                geometry=(["index"], gdf["geometry"])
            )

    def write_response_units(self):
        """Write response_units at <root/?/> in xarray.Dataset and a GeoJSON of the geometry"""
        if not self._write:
            raise IOError("Model opened in read-only mode")
        elif not self._response_units:
            self.logger.warning("No response_units data to write - Exiting")
            return
        # filename
        self.logger.info(f"Write response_units to {self.root}")

        ds_out = self.response_units
        # coordinates that hold geometries
        corl = list(ds_out.coords)
        geom_coords = [v for v in corl if 'geometry' in v]
        # drop items that are objects
        ds_out.drop(geom_coords).drop(["crs","spatial_ref"]).to_netcdf(
            join(self.root, "response_units", "response_units.nc")
        )
        for g in geom_coords:
            gdf = workflows.ru_geometry_to_gpd(ds_out, geometry_name = g)
            gdf.to_file(join(self.root, "response_units", g+".GeoJSON"))

    def set_response_units(
        self, data: Union[xr.DataArray, xr.Dataset], name: Optional[str] = None
    ):
        """Add data to response_units.

        All layers of repsonse_units must have identical spatial index.

        Parameters
        ----------
        data: xarray.DataArray or xarray.Dataset
            new data to add to response_units
        name: str, optional
            Name of new data, this is used to overwrite the name of a DataArray
            or to select a variable from a Dataset.
        """
        if name is None:
            if isinstance(data, xr.DataArray) and data.name is not None:
                name = data.name
            elif not isinstance(data, xr.Dataset):
                raise ValueError("Setting a layer requires a name")
        elif name is not None and isinstance(data, xr.Dataset):
            data_vars = list(data.data_vars)
            if len(data_vars) == 1 and name not in data_vars:
                data = data.rename_vars({data_vars[0]: name})
            elif name not in data_vars:
                raise ValueError("Name not found in DataSet")
            else:
                data = data[[name]]
        if isinstance(data, xr.DataArray):
            data.name = name
            data = data.to_dataset()
        if np.all(
            len(self._response_units) == 0 and "geometry" in data.coords
        ):  # new data with a geometry
            self._response_units = data
        else:
            for dvar in data.data_vars.keys():
                if dvar in self._response_units:
                    if self._read:
                        self.logger.warning(f"Replacing data for: {dvar}")
                self._response_units[dvar] = data[dvar]

    @property
    def response_units(self):
        """xr.Dataset object with an object of shapely object of the Geometry"""
        if not self._response_units:
            if self._read:
                self.read_response_units()
        return self._response_units

    @property
    def shape(self):
        return self._response_units.coords["index"].shape
